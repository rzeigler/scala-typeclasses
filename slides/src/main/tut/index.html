<!DOCTYPE html>
<html>
  <head>
    <title>Typeclasses in Scala</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Typeclasses in Scala

Ryan Zeigler


---

# What Is A Typeclass?

Term typeclass comes from Haskell

Ad-hoc polymorphism

A contract for a type just like an interface

--

Lets see an example

--

```tut:silent
final case class Rational(p: Int, q: Int) {
  def compareTo(o: Rational): Int = p * o.q - o.p * q
}

object Rational {
  implicit val rationalOrdering: Ordering[Rational] = new Ordering[Rational] {
    def compare(a: Rational, b: Rational): Int = a.p * b.q - b.p * a.q
  }
}
```

---

# Encoding in Scala

Typeclasses are traits

Methods on the trait general take arguments of the instance type

Instances for types are implicits

Requiring an instance means taking an implicit parameter

```scala
class List[A] {
  // ...
  def sorted(implicit ev: Ordering[A]): List[A]
  // ...
}
```

Given an `Ordering[A]` I can produce a sorted `List[A]`

---

# Why Would We Want This?

The simplest typeclass uses are easily encodable with interfaces

`Ordering[A]` is more or less the same as `implements Comparable[A]`

With the typeclass approach we can define operations that rely on typeclass at the point of consumption. 

Java has Collections which is a bag of static methods that handles sorting everything

???
IMO this is easier to think about

---

# Why Would We Want This - Interlude?

A Semigroup is something with an append/addition operation

Some common examples of semigroups:
  Int, Double, String, List

```tut:silent
trait Semigroup[A] {
  def append(a1: A, a2: A): A
}
```

A Monoid is a semigroup with the addition of an identity element.

Think `0` for Int, `""` for String

```tut:silent
trait Monoid[A] extends Semigroup[A] {
  def empty: A
}
```

---

# Why Would We Want This - Derivable Instances

```tut:silent
implicit val intMonoid: Monoid[Int] = new Monoid[Int] {
  def append(a1: Int, a2: Int): Int = a1 + a2
  def empty: Int = 0
}

implicit def optionMonoid[A: Semigroup]: Monoid[Option[A]] = 
  new Monoid[Option[A]] {
    def append(a1: Option[A], a2: Option[A]): Option[A] = 
      a1.flatMap(a => a2.map(b => implicitly[Semigroup[A]].append(a, b)))
        .orElse(a1)
        .orElse(a2)
    def empty: Option[A] = None
  }
```

---

# Why Would We Want This

--

* Automatic derivation; Instances based on typeclass instances of other types

--

* If we have a `Semigroup[A]` we automatically have a `Monoid[Option[A]]`

--

* This kind of dependent relationship is hard to express with interfaces 
  but is common with the decoupling provided by typeclasses

--

* `class Option[A] extends Monoid[Option[A]] when A <: Semigroup` ?!?!

???

Semigroups but not monoids (NEL, NEV)...

---

# Why Would We Want This

* We can mix together typeclass constraints to build powerful abstractions

* Ever wanted to quickly sum the numbers in some collection


```tut:silent
def sum[A: Monoid](as: List[A]): A = 
  as.foldLeft(implicitly[Monoid[A]].empty)(implicitly[Monoid[A]].append)
```
```tut
sum(List(1, 2, 3))
```
--

* Oh, the requirements changed, now we have to some records that may or may not have numbers and those should be treated as 0...

--

```tut
sum(List(Some(1), Some(2), None, Some(3)))
```

---

# Typeclass Providers

* There are several projects/ecosystems that provide typeclasses
--
* [scalaz](https://github.com/scalaz/scalaz) - the original; monolithic; in development version 8 is experimenting with a new encoding
--
* [cats](https://github.com/typelevel/cats) - newer; ecosystem of projects roughly equivalent to scalaz
--
* [spire](https://github.com/typelevel/spire) - also typelevel; types and typeclasses for numeric operations
--
* All of these provide Semigroup and Monoid before you roll your own

---
# Common Typeclass and Their Uses

To access all of these implicits you can import the following.


```tut:reset:silent
import cats._
import cats.data._
import cats.implicits._
```

Typeclasses are expected to have laws to which they conform. 
These laws are what allow composition of arbitrary types to work and usually do something sensible (although not always useful)

---

# Functor

... Things that have map

```tut:silent
def add1[F[_]: Functor](fa: F[Int]): F[Int] = fa.map(_ + 1)
```

```tut
add1(42.some)
add1(List(42, 43, 44))
add1(42.asRight[String])
```

???
Make sure to discuss syntax

---
Laws

* Mapping with identity must be the same as applying identity

```tut:silent
def id[F[_]: Functor, A](fa: F[A]): Unit = 
  assert(fa.map(identity) == identity(fa))
```

* Mapping with the composition of 2 functions is the same as mapping one then the other

```tut:silent
def composition[F[_]: Functor, A, B, C](fa: F[A], f: A => B, g: B => C): Unit = 
  assert(fa.map(f.andThen(g)) == fa.map(f).map(g))
```

---

# Unusual Functors

* Functions!

```tut
val strLen = (s: String) => s.length
val strLenX4 = strLen.fmap(_ * 4)
strLenX4("abc")
```

* Parsers!

```tut:silent
import io.circe._
import io.circe.parser.decode
```

```tut
implicit val reverseString = Decoder[Int].map(_.toString.reverse)
decode[String]("24")(reverseString)
```

???

What is the meaning of these fun tricks
Functions... the 'value' contained is the rsult of application
So mapping a f with g is the same as composing f with g

Parsers... you can always apply a function to the result of a parse if it was successful
Its like mapping of an either produced by the parse

 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>